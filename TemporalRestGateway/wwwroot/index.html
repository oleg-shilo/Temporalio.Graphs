<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<title>Temporalio.Graphs</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="">
<style>
    table,
    th,
    td {
        text-align: left;
        vertical-align: top;
        border-collapse: collapse;
        padding-left: 20px;
    }

    tr {
        border-bottom: 1px solid lightslategray;
    }

    .queue {
        border-bottom: 0px;
    }

    select option {
        width: 150px;
        min-width: 150px;
    }

    button {
        /* width: 150px; */
    }

    .dropdowns option:checked {
        background: transparent;
        color: black;

    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"></script>

<script>
    var wfId = "";
    var runId = "";
    var pollingDelay = 1000;
    var waiting = false;
    var executions = [];

    function retrieveWfInfo() {
        fetch('/api/workflows')
            .then(response => response.json()) // Parse JSON response
            .then(data => {

                let wfInfo = `
                <p> <b>WorkflowId:</b> ${wfId}<br>
                    <b>RunId:</b> ${runId}</p>
                    `;
                document.getElementById('result').innerHTML = wfInfo;

                retrieveWfEvents();
            })
            .catch(error => {
                // Handle errors
                console.error('Error fetching data:', error);
            });
    }

    function getStatus() {
        fetch(`/api/status`)
            .then(response => response.json())
            .then(data => {
                // console.log(data);

                if (data?.serverAvailable === true)
                    waiting = false;

                let serverStatus = (data?.serverAvailable !== true) ? (waiting ? "waiting..." : "not running") : "running";
                let workerStatus = (data?.workerAvailable !== true) ? "not running" : "running";

                document.getElementById('serverStatus').innerHTML = `${serverStatus}`;
                document.getElementById('workerStatus').innerHTML = `${workerStatus}`;

                executions = data?.executions;
                let pending = "";
                let inprogress = "";
                let processed = "";

                for (let i = 0; i < executions.length; i++) {
                    let e = executions[i];
                    let id = e.workflow_id.length > 17 ? e.workflow_id.substring(0, 17) + "..." : e.workflow_id;
                    let itemHtml = `<option onclick="selectWorkflow('${e.workflow_id}')">${id}</option>`;

                    if (e.completion_status === 'pending')
                        pending += itemHtml;
                    else if (e.completion_status === 'inprogress')
                        inprogress += itemHtml;
                    else if (e.completion_status === 'processed')
                        processed += itemHtml;
                }

                document.getElementById('pendingQueue').innerHTML = (pending === "" ? "<option>&nbsp</option>" : pending);
                document.getElementById('inprogressQueue').innerHTML = (inprogress === "" ? "<option>&nbsp</option>" : inprogress);
                document.getElementById('processedQueue').innerHTML = (processed === "" ? "<option>&nbsp</option>" : processed);

                retrieveWfInfo();

                setTimeout(getStatus, pollingDelay);
            });
    }

    function startServer() {
        fetch(`/api/start-server`);
        waiting = true;
        document.getElementById('serverStatus').innerHTML = `...`;
    }

    function stopServer() {
        fetch(`/api/stop-server`);
        document.getElementById('serverStatus').innerHTML = `...`;
    }

    function startWorkflow() {
        fetch(`/api/start-wf`);
    }

    function startWorker() {
        fetch(`/api/start-worker`);
        document.getElementById('workerStatus').innerHTML = `...`;
    }

    function stopWorker() {
        fetch(`/api/stop-worker`);
        document.getElementById('workerStatus').innerHTML = `...`;
    }

    function selectWorkflow(arg) {
        // alert("Selected: " + arg);
        let execution = executions.find(e => e.workflow_id === arg);
        if (execution) {
            wfId = execution.workflow_id;
            runId = execution.run_id;

            let wfInfo = `
                <p> <b>WorkflowId:</b> ${wfId}<br>
                    <b>RunId:</b> ${runId}</p>
                    `;
            document.getElementById('result').innerHTML = wfInfo;
            retrieveWfInfo();
        }
    }

    function retrieveWfEvents() {
        if (wfId === "") {
            return;
        }

        console.log("<" + wfId);
        fetch(`/api/workflows/${wfId}/runs/${runId}`)
            .then(response => response.json())
            .then(data => {
                // console.log(data);
                let eventsInfo = `<table>
                <tr>
                    <th>Event</th>
                    <th>Activity</th>
                    <th>Name</th>
                    <th>Started</th>
                    <th>Details</th>
                </tr>`;

                for (let index = 0; data.events && index < data.events.length; index++) {
                    const event = data.events[index];

                    if (index === 0
                        && (event.eventType == "WorkflowExecutionStarted" || event.eventType == "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED")) {
                        let attr = event.workflowExecutionStartedEventAttributes;
                        if (attr.input.payloads.length > 0) {
                            var inputData = decodeURIComponent(atob(attr.input.payloads[0].data));
                            document.getElementById('wfInput').innerHTML = inputData;
                        }
                    }

                    // CLI vs grpc; the constants are encoded somewhat differently
                    if (event.eventType == "ActivityTaskScheduled" || event.eventType == "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED") {

                        let attr = event.activityTaskScheduledEventAttributes;

                        let activityContext = "";
                        let payloads = attr.input.payloads;
                        if (attr.input.payloads.length > 3) {

                            let id = atob(payloads[2].data);
                            let decodedName = atob(payloads[1].data);
                            decodedName = decodeURIComponent(JSON.parse(decodedName));
                            activityContext = `Name: '${decodedName}'; &nbsp;&nbsp;&nbsp;Id: ${id}`;
                        }

                        eventsInfo += `
                                <tr>      
                                    <td> ${event.eventId} </td>
                                    <td> ${attr.activityId}</td> 
                                    <td> ${attr.activityType.name} </td>
                                    <td> ${new Date(event.eventTime).toLocaleString()} </td>
                                    <td> ${activityContext} </td>
                                    </tr>`;
                    }
                }
                eventsInfo += `</table>`;

                document.getElementById('history').innerHTML = eventsInfo;

            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }

    document.addEventListener('DOMContentLoaded', function () {
        setTimeout(getStatus, 200);
        setTimeout(startServer, 200);
    });


</script>

<body>

    <div>
        <table>
            <tr class="queue">
                <td>Pending Workflows </td>
                <td>In-progress Workflows </td>
                <td>Completed Workflows </td>
                <td> <a href="http://localhost:8233/namespaces/default/workflows">Temporal Dashboard</a></td>
                <td> </td>
            </tr>
            <tr class="queue">
                <td>
                    <div class="dropdowns">
                        <select id="pendingQueue" size="10">
                            <option>&nbsp;</option>
                        </select>
                    </div>
                </td>
                <td>
                    <div class="dropdowns">
                        <select id="inprogressQueue" size="10">
                            <option>&nbsp;</option>
                        </select>
                    </div>
                </td>
                <td>
                    <div class="dropdowns">
                        <select id="processedQueue" size="10">
                            <option>&nbsp;</option>
                        </select>
                    </div>
                </td>
                <td>
                    <table>
                        <tr>
                            <td> <b>Server:</b> </td>
                            <td> <a href="javascript:null" onclick="startServer()">Start</a></td>
                            <td> <a href="javascript:null" onclick="stopServer()">Stop</a></td>
                            <td> <span id="serverStatus">...</span> </td>
                        </tr>

                        <tr>
                            <td> <b>Worker:</b> </td>
                            <td> <a href="javascript:null" onclick="startWorker()">Start</a></td>
                            <td> <a href="javascript:null" onclick="stopWorker()">Stop</a></td>
                            <td> <span id="workerStatus">...</span> </td>
                        </tr>
                        <tr>
                            <td> <b>Workflow:</b> </td>
                            <td> <a href="javascript:null" onclick="startWorkflow()">Start</a></td>
                            <td> </td>
                            <td> </td>
                        </tr>
                    </table>
                </td>
        </table>
        </tr>

        <h3>Selected WF </h3>
        <div id="result"></div>
        <div> <b>Input: </b>
            <pre><span id="wfInput"></span> </pre>
        </div>
        <hr>
        <div class="mermaid"></div>
        <pre id="err"></pre>
        <hr>
        <h3>WF events:</h3>
        <div id="history"></div>

        <script>
            mermaid.initialize({
                startOnLoad: true,
                flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'cardinal' },
                securityLevel: 'loose'
            });

            eleM = document.querySelector('.mermaid');
            eleE = document.querySelector('#err');

            setTimeout(mermaidDraw, 200);

            async function mermaidDraw() {
                try {
                    graphDefinition = await getMermaidDefinition();
                    const {
                        svg
                    } = await mermaid.render('graphDiv', graphDefinition);
                    eleM.innerHTML = svg;

                    setTimeout(addClickHandlers, 200);

                } catch (err) {
                    if (err instanceof ReferenceError) {
                        varname = err.message.split(' ')[0];
                        window[varname] = varname;
                        setTimeout(mermaidDraw, 0);
                    }
                    console.error(err);
                    eleE.insertAdjacentHTML('beforeend', `ðŸš«${err.message}\n`);
                }
            };

            async function getMermaidDefinition() {
                let text = `
flowchart LR
s((In)) --> Withdraw
Withdraw --> -1485020306{Currency != ' AUD'}
-1485020306{Currency != ' AUD'} -- yes --> ConvertCurrency[Convert Currency]
ConvertCurrency[Convert Currency] --> 78577353{Is TFN Known}
78577353{Is TFN Known} -- yes --> NotifyAto[Notify Ato]
NotifyAto[Notify Ato] --> Deposit
Deposit --> 1546202137{{Interpol Check}}
1546202137{{Interpol Check}} -- Signaled --> Refund
Refund --> NotifyPolice[Notify Police]
NotifyPolice[Notify Police] --> e((Out))
78577353{Is TFN Known} -- no --> TakeNonResidentTax[Take Non Resident Tax]
TakeNonResidentTax[Take Non Resident Tax] --> Deposit
-1485020306{Currency != ' AUD'} -- no --> 78577353{Is TFN Known}
1546202137{{Interpol Check}} -- Timeout --> e((Out))
            `;
                text = text + `\n\nclassDef activeStep fill:#e94,stroke-width:1px;\nclassDef selectedStep stroke:#f96,stroke-width:2px;`;
                return text;
            }

            function toMermaidId(nodeText) {
                return nodeText
                    .split("[")[0]
                    .split("(")[0]
                    .split("-")[0]
                    .trim();
            }

            function setNodeUniqueClass(node, className) {
                const nodes = document.querySelectorAll('g.node');
                nodes.forEach(nd => {
                    nd.classList.remove(className);
                    if (nd === node) {
                        node.classList.add(className);
                    }
                });
            }

            function nextStep() {
                const nodes = document.querySelectorAll('g.node');

                let found = false;
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].matches('.activeStep')) {
                        nodes[i].classList.remove("activeStep");

                        if (i + 1 >= nodes.length)
                            nodes[0].classList.add("activeStep");
                        else
                            nodes[++i].classList.add("activeStep");

                        found = true;
                    }
                }

                if (!found)
                    nodes[0].classList.add("activeStep");
            }

            function isStarted(node) {
                const nodes = document.querySelectorAll('g.node');

                let found = -1;
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].matches('.activeStep')) {
                        found = i;
                        if (nodes[i] === node) {
                            return { started: true, finished: false };
                        }
                        break;
                    }
                }

                if (found !== -1) {
                    if (Array.from(nodes).slice(0, found).includes(node))
                        return { started: true, finished: true };
                    else
                        return { started: false, finished: false };
                }

                return false;
            }

            function handleClick(node, parentDataId) {

                setNodeUniqueClass(node, "selectedStep");

                const info = document.querySelector('#stepInfo');
                parentDataId = toMermaidId(parentDataId);
                let status = "<pending>";
                let runId = generateRandomUUID();
                let start = "...";
                let end = "...";
                let duration = "...";

                let stepDetails = isStarted(node);
                if (stepDetails.started) {
                    status = stepDetails.finished ? "completed" : "In progress";

                    const now = new Date(); // Get the current date and time
                    const tenMinutesAgo = new Date(now.getTime() - 10 * 60 * 1000);
                    start = tenMinutesAgo.toLocaleString();
                    if (stepDetails.finished) {
                        end = tenMinutesAgo.toLocaleString();
                        duration = "45 sec";
                    }
                }
                info.innerHTML = `Id: '${parentDataId}'<br>Status: ${status}<br>RunId: ${runId}<br>Started: ${start}<br>Completed: ${end}<br>Duration: ${duration}`;

            }


            function addClickHandlers() {

                // it's possible to use `click nodeId callback " "` directly in the mermaid definition but it will means parsing the 
                // definition, which only mermaid should do
                const nodes = document.querySelectorAll('g.node');
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    node.addEventListener('click', (event) => {
                        const clickedNode = event.target.closest('g'); // Get the closest <g> element (the node)
                        clickedNode.setAttribute("cursor", "hand");
                        const nodeId = clickedNode.id;
                        const parentNode = clickedNode.parentElement;
                        const parentDataId = parentNode.getAttribute('data-id') || 'No data-id attribute';
                        handleClick(node, parentDataId);
                    });
                });
            }

            function generateRandomUUID() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
                    .replace(/[xy]/g, function (c) {
                        const r = Math.random() * 16 | 0;
                        const v = c === 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
            }
        </script>


</body>

</html>